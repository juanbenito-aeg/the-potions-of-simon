import simon from "./assets/sounds/sprite.mp3";
import defeatDialogImage from "./assets/images/defeat-dialog.png";
import "./App.css";
import useSound from "use-sound";
import { useState, useEffect, useRef } from "react";

function App() {
  const redPotionRef = useRef(null);
  const bluePotionRef = useRef(null);
  const greenPotionRef = useRef(null);
  const purplePotionRef = useRef(null);
  const defeatDialogRef = useRef(null);

  const [play] = useSound(simon, {
    sprite: {
      one: [0, 500],
      two: [1000, 500],
      three: [2000, 500],
      four: [3000, 500],
      error: [4000, 1000],
    },
  });

  const potions = [
    {
      ref: redPotionRef,
      sound: "one",
    },
    {
      ref: bluePotionRef,
      sound: "two",
    },
    {
      ref: greenPotionRef,
      sound: "three",
    },
    {
      ref: purplePotionRef,
      sound: "four",
    },
  ];

  const minNumber = 0;
  const maxNumber = 3;
  const speedGame = 400;

  const [sequence, setSequence] = useState([]); // SEQUENCE GENERATED BY THE GAME
  const [currentGame, setCurrentGame] = useState([]); // SEQUENCE EXECUTED BY THE PLAYER
  const [isAllowedToPlay, setIsAllowedToPlay] = useState(false); // SPECIFIES WHETHER THE PLAYER IS ALLOWED TO PRESS A POTION OR NOT
  const [speed, setSpeed] = useState(speedGame); // GAME SPEED
  const [turn, setTurn] = useState(0); // NUMBER OF THE TURN CURRENTLY BEING EXECUTED
  const [pulses, setPulses] = useState(0); // NUMBER OF PULSES
  const [success, setSuccess] = useState(0); // NUMBER OF SUCCESSFUL PULSES
  const [isGameOn, setIsGameOn] = useState(false); // SPECIFIES WHETHER THE GAME SHOULD START

  const initGame = () => {
    randomNumber();

    setIsGameOn(true);
  };

  const randomNumber = () => {
    setIsAllowedToPlay(false);

    const randomNumber = Math.floor(
      Math.random() * (maxNumber - minNumber + 1) + minNumber
    );
    setSequence([...sequence, randomNumber]);

    setTurn(turn + 1);
  };

  const handleClick = (index) => {
    if (isAllowedToPlay) {
      play({ id: potions[index].sound });

      potions[index].ref.current.style.backgroundColor = "transparent";

      // |||||||||||||||| GET THE POTION'S CENTER X & Y COORDINATES TO CREATE PARTICLES IN IT

      const potionSizeAndPosition =
        potions[index].ref.current.getBoundingClientRect();

      const potionCenterX =
        potionSizeAndPosition.x + potionSizeAndPosition.width / 2;
      const potionCenterY =
        potionSizeAndPosition.y + potionSizeAndPosition.height / 2;

      createParticles(potionCenterX, potionCenterY);

      setTimeout(() => {
        potions[index].ref.current.style.backgroundColor = "rgb(0 0 0 / 0.25)";

        setCurrentGame([...currentGame, index]);

        setPulses(pulses + 1);
      }, speed / 2);
    }
  };

  const createParticles = (x, y) => {
    for (let i = 0; i < 15; i++) {
      const particle = document.createElement("div");

      document.body.appendChild(particle);

      particle.className = "particle";

      const size = Math.floor(Math.random() * 11 + 10);
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;

      // |||||||||||||||| GENERATE A RANDOM X & Y DESTINATION WITHIN A DISTANCE OF 100PX FROM THE POTION'S CENTER
      const destinationX = x + (Math.random() - 0.5) * 2 * 100;
      const destinationY = y + (Math.random() - 0.5) * 2 * 100;

      const rotation = Math.random() * 520;

      const animation = particle.animate(
        [
          {
            transform: `translate(-50%, -50%) translate(${x}px, ${y}px) rotate(0)`, // SET THE ORIGIN POSITION OF THE PARTICLE
            opacity: 1,
          },
          {
            transform: `translate(${destinationX}px, ${destinationY}px) rotate(${rotation}deg)`, // DEFINE THE FINAL COORDINATES
            opacity: 0,
          },
        ],
        {
          duration: Math.random() * 1000 + 1500,
          easing: "cubic-bezier(0, 0.9, 0.57, 1)",
          delay: Math.random() * 200,
        }
      );

      animation.addEventListener("finish", () => {
        particle.remove();
      });
    }
  };

  // |||||||||||||||| CHECK WHETHER THE POTION PRESSED IS CORRECT OR NOT
  useEffect(() => {
    if (pulses > 0) {
      const lastCorrectIndex = sequence[pulses - 1];

      if (currentGame[pulses - 1] === lastCorrectIndex) {
        setSuccess(success + 1);
      } else {
        play({ id: "error" });

        potions[lastCorrectIndex].ref.current.style.backgroundColor =
          "transparent";

        setTimeout(() => {
          potions[lastCorrectIndex].ref.current.style.backgroundColor =
            "rgb(0 0 0 / 0.25)";

          displayDefeatDialog();
        }, speed * 2);

        setIsAllowedToPlay(false);
      }
    }
  }, [pulses]);

  const displayDefeatDialog = () => {
    defeatDialogRef.current.showModal();
  };

  // |||||||||||||||| RESET THE GAME WHEN THE POTION PRESSED IS INCORRECT
  useEffect(() => {
    if (!isGameOn) {
      setSequence([]);
      setCurrentGame([]);
      setIsAllowedToPlay(false);
      setSpeed(speedGame);
      setSuccess(0);
      setPulses(0);
      setTurn(0);
    }
  }, [isGameOn]);

  useEffect(() => {
    if (success > 0 && success === sequence.length) {
      setSpeed(speed - sequence.length * 2);

      setTimeout(() => {
        setSuccess(0);
        setPulses(0);
        setCurrentGame([]);
        randomNumber();
      }, 500);
    }
  }, [success]);

  // |||||||||||||||| PLAY THE SEQUENCE EVERY TIME IT IS UPDATED
  useEffect(() => {
    if (!isAllowedToPlay) {
      sequence.forEach((item, index) => {
        setTimeout(() => {
          play({ id: potions[item].sound });

          potions[item].ref.current.style.backgroundColor = "transparent";

          setTimeout(() => {
            potions[item].ref.current.style.backgroundColor =
              "rgb(0 0 0 / 0.25)";

            if (index === sequence.length - 1) {
              setIsAllowedToPlay(true);
            }
          }, speed / 2);
        }, speed * index);
      });
    }
  }, [sequence]);

  return (
    <>
      {isGameOn ? (
        <div className="game">
          {/* <div className="header">
            <h1>Turn {turn}</h1>
          </div> */}

          <div className="game__potions-container">
            {potions.map((item, index) => {
              return (
                <div
                  key={index}
                  ref={item.ref}
                  className={`game__potion game__potion-${index}`}
                  onClick={() => {
                    handleClick(index);
                  }}
                ></div>
              );
            })}
          </div>

          <dialog
            closedby="none"
            ref={defeatDialogRef}
            className="game__defeat-dialog"
          >
            <img src={defeatDialogImage} alt="" />

            <div className="game__defeat-dialog__elems-container">
              <p className="game__defeat-dialog__txt">
                One misstep is all it takes. The potions flicker out of order,
                their glow faltering before dissolving into nothingness. The
                sequence is broken, and with it, the challenge ends. You have
                been defeated.
              </p>

              <button
                type="button"
                className="game__defeat-dialog__btn"
                onClick={() => {
                  setIsGameOn(false);
                }}
              >
                Return to the main menu
              </button>
            </div>
          </dialog>
        </div>
      ) : (
        <>
          <div className="header">
            <h1>SUPER SIMON</h1>

            <button type="button" onClick={initGame}>
              START
            </button>
          </div>
        </>
      )}
    </>
  );
}

export default App;
