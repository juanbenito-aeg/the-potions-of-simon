import simon from "./assets/sounds/sprite.mp3";
import "./App.css";
import useSound from "use-sound";
import { useState, useEffect, useRef } from "react";

function App() {
  const redPotionRef = useRef(null);
  const bluePotionRef = useRef(null);
  const greenPotionRef = useRef(null);
  const purplePotionRef = useRef(null);

  const [play] = useSound(simon, {
    sprite: {
      one: [0, 500],
      two: [1000, 500],
      three: [2000, 500],
      four: [3000, 500],
      error: [4000, 1000],
    },
  });

  const potions = [
    {
      ref: redPotionRef,
      sound: "one",
    },
    {
      ref: bluePotionRef,
      sound: "two",
    },
    {
      ref: greenPotionRef,
      sound: "three",
    },
    {
      ref: purplePotionRef,
      sound: "four",
    },
  ];

  const minNumber = 0;
  const maxNumber = 3;
  const speedGame = 400;

  const [sequence, setSequence] = useState([]); // SEQUENCE GENERATED BY THE GAME
  const [currentGame, setCurrentGame] = useState([]); // SEQUENCE EXECUTED BY THE PLAYER
  const [isAllowedToPlay, setIsAllowedToPlay] = useState(false); // SPECIFIES WHETHER THE PLAYER IS ALLOWED TO PRESS A POTION OR NOT
  const [speed, setSpeed] = useState(speedGame); // GAME SPEED
  const [turn, setTurn] = useState(0); // NUMBER OF THE TURN CURRENTLY BEING EXECUTED
  const [pulses, setPulses] = useState(0); // NUMBER OF PULSES
  const [success, setSuccess] = useState(0); // NUMBER OF SUCCESSFUL PULSES
  const [isGameOn, setIsGameOn] = useState(false); // SPECIFIES WHETHER THE GAME SHOULD START

  const initGame = () => {
    randomNumber();

    setIsGameOn(true);
  };

  const randomNumber = () => {
    setIsAllowedToPlay(false);

    const randomNumber = Math.floor(
      Math.random() * (maxNumber - minNumber + 1) + minNumber
    );
    setSequence([...sequence, randomNumber]);

    setTurn(turn + 1);
  };

  const handleClick = (index) => {
    if (isAllowedToPlay) {
      play({ id: potions[index].sound });

      potions[index].ref.current.style.backgroundColor = "transparent";

      setTimeout(() => {
        potions[index].ref.current.style.backgroundColor = "rgb(0 0 0 / 0.25)";

        setCurrentGame([...currentGame, index]);

        setPulses(pulses + 1);
      }, speed / 2);
    }
  };

  // |||||||||||||||| CHECK WHETHER THE POTION PRESSED IS CORRECT OR NOT
  useEffect(() => {
    if (pulses > 0) {
      const lastCorrectIndex = sequence[pulses - 1];

      if (currentGame[pulses - 1] === lastCorrectIndex) {
        setSuccess(success + 1);
      } else {
        play({ id: "error" });

        potions[lastCorrectIndex].ref.current.style.backgroundColor =
          "transparent";

        setTimeout(() => {
          potions[lastCorrectIndex].ref.current.style.backgroundColor =
            "rgb(0 0 0 / 0.25)";

          setIsGameOn(false);
        }, speed * 2);

        setIsAllowedToPlay(false);
      }
    }
  }, [pulses]);

  // |||||||||||||||| RESET THE GAME WHEN THE POTION PRESSED IS INCORRECT
  useEffect(() => {
    if (!isGameOn) {
      setSequence([]);
      setCurrentGame([]);
      setIsAllowedToPlay(false);
      setSpeed(speedGame);
      setSuccess(0);
      setPulses(0);
      setTurn(0);
    }
  }, [isGameOn]);

  useEffect(() => {
    if (success > 0 && success === sequence.length) {
      setSpeed(speed - sequence.length * 2);

      setTimeout(() => {
        setSuccess(0);
        setPulses(0);
        setCurrentGame([]);
        randomNumber();
      }, 500);
    }
  }, [success]);

  // |||||||||||||||| PLAY THE SEQUENCE EVERY TIME IT IS UPDATED
  useEffect(() => {
    if (!isAllowedToPlay) {
      sequence.forEach((item, index) => {
        setTimeout(() => {
          play({ id: potions[item].sound });

          potions[item].ref.current.style.backgroundColor = "transparent";

          setTimeout(() => {
            potions[item].ref.current.style.backgroundColor =
              "rgb(0 0 0 / 0.25)";

            if (index === sequence.length - 1) {
              setIsAllowedToPlay(true);
            }
          }, speed / 2);
        }, speed * index);
      });
    }
  }, [sequence]);

  return (
    <>
      {isGameOn ? (
        <div className="game">
          {/* <div className="header">
            <h1>Turn {turn}</h1>
          </div> */}

          <div className="game__potions-container">
            {potions.map((item, index) => {
              return (
                <div
                  key={index}
                  ref={item.ref}
                  className={`game__potion game__potion-${index}`}
                  onClick={() => {
                    handleClick(index);
                  }}
                ></div>
              );
            })}
          </div>
        </div>
      ) : (
        <>
          <div className="header">
            <h1>SUPER SIMON</h1>

            <button type="button" onClick={initGame}>
              START
            </button>
          </div>
        </>
      )}
    </>
  );
}

export default App;
